[{"content":"Bilibili Danmu Blacklists Bilibili 弹幕屏蔽词分享网站，分享你的 bilibili 弹幕屏蔽词。\nShare, import and manage your bilibili danmu blacklist!\nWebsite Source Cipher 网页解密游戏，由我和氢氧化氢共同制作。\nSome puzzles for daring people! Made by 氢氧化氢 and me.\nPlay nazo.games 另一个网页解密游戏。更加 CTF 一些，和上面一个的风格不大一样，题目也完全不同。\nAnother puzzle game mixed with CTF elements.\nPlay Source Wox Dictionary / Flow Dictionary 给 Wox / Flow Launcher 写的多功能词典插件。\nA Wox dictionary plugin that supports spelling correction and synonym lookups.\nSource for Wox Source for Flow Launcher SchoolPower PowerSchool 的现代化第三方客户端。\nAn alternative client for PowerSchool, designed by students, for students. Contact me if you\u0026rsquo;re students/administrators and want to use it for your school.\nWebsite Source for Backend Source for Android Source for iOS Source for Web NEWorld 3D 体素沙盒游戏，就像 Minecraft 一样。\nA 3D voxel sandbox game, written with C++ and OpenGL, without any game engines!\nSource Misc Just yet another simple ray tracer written for fun Source An idle game written for EMagic Jam / ByteTech 1024 Hackathon @ ByteDance Play Source Random anime wallpaper api powered by /r/Animewallpaper. Source Blog post MyWatCard, A user-friendly mobile app for WatCard. Source ","permalink":"http://localhost:1313/projects/","summary":"Bilibili Danmu Blacklists Bilibili 弹幕屏蔽词分享网站，分享你的 bilibili 弹幕屏蔽词。\nShare, import and manage your bilibili danmu blacklist!\nWebsite Source Cipher 网页解密游戏，由我和氢氧化氢共同制作。\nSome puzzles for daring people! Made by 氢氧化氢 and me.\nPlay nazo.games 另一个网页解密游戏。更加 CTF 一些，和上面一个的风格不大一样，题目也完全不同。\nAnother puzzle game mixed with CTF elements.\nPlay Source Wox Dictionary / Flow Dictionary 给 Wox / Flow Launcher 写的多功能词典插件。\nA Wox dictionary plugin that supports spelling correction and synonym lookups.\nSource for Wox Source for Flow Launcher SchoolPower PowerSchool 的现代化第三方客户端。","title":"Projects"},{"content":"Hackergame (中国科学技术大学第八届信息安全大赛) 传送门：hackergame\n这次摸了个 rank 31 (卷不动了)。这里挑了几道感觉比较有意思的题目写 write-up。\n卖瓜 你：你瞧瞧现在哪有瓜啊？这都是大棚的瓜，只有 6 斤一个和 9 斤一个的，你嫌贵我还嫌贵呢。\nHQ：给我来 20 斤的瓜。\n你：行！\nHQ：行？这瓜能称出 20 斤吗？\n你：我开水果摊的，还不会称重？\nHQ：我问你这瓜能称出 20 斤吗？\n你：你是故意找茬，是不是？你要不要吧！\nHQ：你这瓜要是刚好 20 斤吗我肯定要啊。那它要是没有怎么办啊？\n你：要是不是 20 斤，我自己吃了它，满意了吧？\n一开始考虑用小数，但是发现就算是直接改 post payload 也不会接受小数输入（好像会被直接 truncate 掉）。顺便试了一下负数也不可以。\n既然小数和负数都不行，那很大的数呢？试了一下 2147483647 也不会导致溢出。本以为是不行了，然后突然想起来时代变了，现在都是 64 位了。试了一下 9223372036854775807/6 = 1537228672809130000 + 6，果然溢出了。\nintval(6+1537228672809130000*6)+(1537228672809128622)*6 == 20 透明的文件 这道题目给了一个包括很多 ANSI escape sequence 的文件，形如下\n[0;0H[20;58H[8;34H[13;27H[4;2H[38;2;1;204;177m [39m[14;10H[20;51H[23;4H[12;2H[38;2;2;207;173m [39m[19;61H[9;12H[22;8H[20;2H[38;2;3;210;169m [39m[3;23H[8;68H[19;10H[4;3H[38;2;4;214;165m [39m[19;23H[17;34H[11;52H[22;70H[12;3H[38;2;5;217;161m [39m[24;22H[2;25H[19;76H[19;3H[38;2;6;220;157m [39m[23;14H[21;12H[10;37H[2;37H[22;66H[16;45H[21;3H[38;2;7;222;153m [39m[10;47H[18;34H[23;3H[38;2;8;225;149m 简单看了下发现并没有空格以外的字符，而且所有 \\e 也都被弄没了，也就是说肯定没法通过 echo -e $(cat transparent.txt) 这种方法直接查看到 flag。\n于是上网找到了一个 python 的 ANSI 解析库，魔改了一下代码让它支持不带 \\e 的 escape sequence，然后输出所有修改过的位置：\nterm = Ansiterm(25, 80) term.feed(f.read()) tiles = Counter() for y in range(25): for tile in term.get_tiles(y * 80, y * 80 + 80): tiles[repr(tile.color)] += 1 default = \u0026#34;{\u0026#39;fg\u0026#39;: 37, \u0026#39;bg\u0026#39;: 40, \u0026#39;reverse\u0026#39;: False, \u0026#39;bold\u0026#39;: False}\u0026#34; print(\u0026#39;\\n\u0026#39;.join( \u0026#39;\u0026#39;.join([\u0026#39;x\u0026#39; if repr(tile.color) != default else \u0026#39; \u0026#39; for tile in term.get_tiles(y * 80, y * 80 + 80)]) for y in range(25))) 输出如下\nxx xx xx x x x xxx x x xxxxx x x xxx x xxx x x x x x xxxx x xx xx x xxxx x x xxxx xxxx x x x x x x x xxxx x x x x x x x x x x x xxxx x x x x x x x x x x x x xx xxx x x xx xxx x xxxx x x x x x x xxx x x x xx x x x xxx xxx x x x xxx x xxx xx xxxx xxx x x x x x x xxxx x x x x x x x x x x x x x x x x x x xx xxxx x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x xxx x x x x xxx x xx x x x xxxx xxx x x x x xxx xx xx xxxx xxx x x x x x x x x x x x x xxxxx xxx x x x xxx xxxxx x xxxx xxxx xxxx x x xxxx x x x x xx x x x x x x x x xxxxx x x xxxx xxx x x x x x x x x x x x x x x xxx xx xxx xx xx FLAG 助力大红包 这题是个 pdd 套路，需要 256 个不同的 /8 ip 地址砍一刀才能获得 flag。\n每个用户只能够助力一次。为了建设世界一流大砍刀平台，活动要求位于同一 /8 网段的用户将会被视为同一个用户。（比如 IP 地址为 202.38.64.1 和 202.39.64.1 将被视为同一用户。）达到助力次数上线后，将无法再帮助好友助力。我们使用前后端方式检查用户的 IP 。 简单试了下，发现是经典的 X-FORWARDED-FOR，于是直接写脚本构造请求。唯一的坑就是有请求限速，所以我还加了个重试循环。\nsucceed_ip=[] while len(succeed_ip)!=256: for i in range(0,256): ip = f\u0026#39;{i}.1.1.1\u0026#39; if ip in succeed_ip: continue txt=requests.post(\u0026#39;http://202.38.93.111:10888/invite/9900a95d-3a58-47c6-8a88-89a093ff9f16\u0026#39;, data={\u0026#39;ip\u0026#39;:ip}, headers={\u0026#39;X-FORWARDED-FOR\u0026#39;:ip}).text suc = \u0026#39;成功\u0026#39; in txt print(ip, suc) if suc: succeed_ip.append(ip) 加密的 U 盘 这道题给了两个 LUKS （Linux Unified Key Setup）加密的镜像，其中第一个镜像的密码是已知的。解密出来发现是一个随机过程.txt，里面是一些数学笔记，并没有什么卵用。加密方式看了眼是 aes-xts-plain64。\n……然后我就跑偏了，以为是一个 known-plaintext attack。啃了半天资料然后看了一眼这道题 general 的 tag，又看了下通关人数，感觉不大对。然后我在一次错误的解密尝试中，想到了该不会 passphrase 和加密用的 key 是不同的吧（废话）。于是就了解到了 master key 这么个东西。\nsudo cryptsetup luksDump --dump-master-key /dev/loop1p1 # 获得 masterkey 的 cat masterkey| xxd -r -p \u0026gt; masterkey.bin sudo cryptsetup --master-key-file masterkey.bin luksOpen /dev/loop1p1 day2 mount /dev/mapper/day2 ./day2 mkdir day2 sudo mount /dev/mapper/day2 ./day2 cat day2/flag.txt 图之上的信息 从 graphql 上拿数据的白给题。\n赛博厨房 这道题本质上是个挖矿题（雾）。前两题都是教程，就不讲了。第四小题我没做出来，也不讲了（x），重点说下第三题。\n通过阅读代码得知，每一天的菜谱是由 sha256( '\\n'.join(sha256(prog) for prog in programs) ) 算出来的值作为随机数种子，然后 ARC4 随机生成出来的。由于 hash 和随机数算法都挺正经的，大概是没法直接碰撞了。\n看了下这道题目有 32 种不同的菜，随机挑选 6 个（有顺序），那么有 P(32,6)=652458240 种可能性。感觉只要运气好，还是可以跑出来的。于是手动实现了一下 ARC4 随机算法（没找到现成的库），然后用巨快的 pypy 跑（其实 cpp 应该更快，只是懒了）。\n代码写得丑就不贴了，思路就是先创建 32 个程序分别对应菜谱为 0,0,0,0,0,0; 1,1,1,1,1,1 \u0026hellip;即六个都一样的场景。然后开始写一个 dummy 程序，内容不重要，能过检查就好。\n我跑出来的结果如下：\n向右 1 步\\n拿起 6 个物品\\n向左 1 步\\n放下 1 个物品\\n放下 1 个物品\\n放下 1 个物品\\n放下 1 个物品\\n放下 1 个物品\\n放下 1 个物品 向右 2 步\\n拿起 6 个物品\\n向左 2 步\\n放下 1 个物品\\n放下 1 个物品\\n放下 1 个物品\\n放下 1 个物品\\n放下 1 个物品\\n放下 1 个物品 ... 向右 32 步\\n拿起 6 个物品\\n向左 32 步\\n放下 1 个物品\\n放下 1 个物品\\n放下 1 个物品\\n放下 1 个物品\\n放下 1 个物品\\n放下 1 个物品 向左 1912766784062 步 这样就可以跑出来一个我们已有的32程序可以解决的菜谱。其实用 128 个程序（上限）更快，但是我懒了（\n马赛克 我最喜欢的一道题目之一，要从打了马赛克的二维码中还原信息。乍一看感觉不大可能，但是其实每个马赛克块的灰度数值其实提供了很多信息，我们完全可以枚举其覆盖的二维码块来找到会产生一致的马赛克块的情况。当然如果同时覆盖了 2*2 的块那就没办法了，不过二维码本身也是有纠错能力的，所以也不需要完全还原。\n脚本在这里：https://gist.github.com/harrynull/10e03907e835c48b7fbae72109381769。写的比较乱，而且要稍微改一下才可以跑。跑出来的结果如下：\nminecRaft 这一题其实就是反混淆源码，然后从常数发现是用的 XTEA 加密。给了密文和密钥求明文。唯一拿出来提一下的原因是我又以为这是道密码学题了，因为我一开始反混淆出来以为是给了明文和密文求密钥，看了下 web 标签和过关人数我才清醒过来。\nJUST BE FUN 很有意思的题目，但是也很繁琐。题目定义了一种船新的、三维的、只有栈的语言，要实现 + * shift or xor pow 运算。作者唯一的温柔是所有的数字都是一位数，所以不用写 readint 了。稍微写了一点之后感觉太麻烦了于是自己编了一个语言和一个编译器，写了400+行代码（其实感觉更麻烦了吧喂）。\n自编语言部分代码：\n# === handle | === $| !s nop* !s \u0026gt; # pop the operator pop # res = 0 # i = 1 0 1 # [op1, op2, res, i] @or_while_cond #while a + b != 0: \u0026gt; fetch 3 fetch 5 + @or_while |* # a+b \u0026gt;= 0: UP wrap up # if a % 2 + b % 2 != 0: fetch 3 2 % fetch 5 2 % + @or_bit_not_zero |* wrap up # res += i # [op1, op2, res, i] dup # [op1, op2, res, i, i] 1 3 \\ # [op1, op2, i, i, res] + # [op1, op2, i, RES] 1 2 \\ # end if } \u0026gt; 编译结果如下： p😭q 最喜欢的题目之一，从频谱动画来还原音频。一件我从来没想过可行，但是一想却觉得很合理的事情。\n这道题目的正解当然是找一位 hifi 发烧友盯着 gif 看一下然后脑内还原音频（bushi）。但是我附近没有发烧友所以我只能写代码还原。\ngif = Image.open(\u0026#34;./flag.gif\u0026#34;) frames = [] for frame in range(8, gif.n_frames): gif.seek(frame) frames.append(np.sum(np.array(gif), axis=0)[3::4] + min_db) frames = np.asarray(frames).transpose() y_inv = librosa.feature.inverse.mel_to_audio( librosa.db_to_power(frames), n_fft=fft_window_size, hop_length=frame_step_size, window=window_function_type ) sf.write(\u0026#39;output.wav\u0026#39;, y_inv, 22050, \u0026#39;PCM_24\u0026#39;) # 634bil 971 mil 243 tho 582 ","permalink":"http://localhost:1313/posts/hackergame-2021-writeup/","summary":"\u003cp\u003eHackergame (中国科学技术大学第八届信息安全大赛) 传送门：\u003ca href=\"https://hack.lug.ustc.edu.cn/\"\u003ehackergame\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e这次摸了个 rank 31 (卷不动了)。这里挑了几道感觉比较有意思的题目写 write-up。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.loli.net/2021/10/30/jG3nUAL1Bt59g7K.jpg\" alt=\"rk.jpg\"  /\u003e\r\n\u003c/p\u003e","title":"Hackergame 2021 Writeup"},{"content":"传送门：2020新年解谜\n祝大家2020元旦快乐。以下是游戏的题解。\n第一关 传送门：第一关。\n答案：对。\n打开后只有闪烁的背景颜色。查看网页源码后发现，颜色闪烁是由 websocket 服务器控制的。\nwindow.addEventListener(\u0026#34;load\u0026#34;, function () { websocket = new WebSocket(\u0026#34;wss://harrynull.tech/2020/ws/lvl1\u0026#34;); websocket.onmessage = function (evt) { $(\u0026#34;body\u0026#34;).animate({ backgroundColor: evt.data == \u0026#39;L\u0026#39; ? \u0026#39;#FFC500\u0026#39; : \u0026#39;#FFA500\u0026#39; }, 500); }; }, false); 实际上，这里的颜色闪烁代表摩尔斯电码。写一个程序分析亮灭之间时间间隔（注意在较差的网络环境下得到时间可能会不大稳定）。\nwebsocket = new WebSocket(\u0026#34;wss://harrynull.tech/2020/ws/lvl1\u0026#34;); function now(){return new Date().getTime(); } var lastL=new Date().getTime(); var lastO=new Date().getTime(); websocket.onmessage = function (evt) { if(evt.data==\u0026#39;L\u0026#39;) {console.log(\u0026#34;Empty \u0026#34; + Math.round((now() - lastO)/1000) ); lastL=now();} if(evt.data==\u0026#39;O\u0026#39;) {console.log(\u0026#34;On \u0026#34; + Math.round((now() - lastL)/1000) ); lastO=now();} }; 可发现间隔时间有Empty 1代表一个短间隔，Empty 3代表一个长间隔，Empty 6代表序列重复间的间隔。On 1代表短，On 2代表长。按照此规则可写出解码程序。\nvar res = \u0026#34;\u0026#34;; websocket.onmessage = function (evt) { if(evt.data==\u0026#39;L\u0026#39;) {res+=(Math.round((now() - lastO)/1000)==1?\u0026#34;\u0026#34;:\u0026#34; \u0026#34;); lastL=now();} if(evt.data==\u0026#39;O\u0026#39;) {res+=(Math.round((now() - lastL)/1000)==1?\u0026#34;.\u0026#34;:\u0026#34;-\u0026#34;); lastO=now();} }; 得到摩尔斯电码. ..... .- ..-. -... ----.，解码得E5AFB9，即对的 utf-8 编码。\n附本关 python 源码\nasync def lvl1(websocket): pattern = \u0026#39;. ..... .- ..-. -... ----.\u0026#39; # E5AFB9 对 while True: for c in pattern: if c==\u0026#39; \u0026#39;: await asyncio.sleep(2) continue await websocket.send(\u0026#39;L\u0026#39;) await asyncio.sleep(1 if c==\u0026#39;.\u0026#39; else 2) await websocket.send(\u0026#39;O\u0026#39;) await asyncio.sleep(1) await asyncio.sleep(5) 第二关 传送门：第二关。\n答案：年。\n观察 URL 可得本关地址。这一关既可以手动/js半手动解，也可以写脚本解。基本方法是二分+递归。\n附本关 python 源码\nasync def lvl2(websocket): import random import time FLAG = \u0026#39;年\u0026#39; CHECK_INTERVAL = 10 i=random.randint(0, 999) j=i while j==i: j=random.randint(0, 999) while True: message = await websocket.recv() message = message[0] + decompress([ord(i) for i in message[1:]]) await asyncio.sleep(CHECK_INTERVAL) if message[0]==\u0026#39;A\u0026#39;: await websocket.send(FLAG if message.count(\u0026#39;1\u0026#39;)==2 and message[i]==\u0026#39;1\u0026#39; and message[j]==\u0026#39;1\u0026#39; else \u0026#39;Incorrect\u0026#39;) elif message[0]==\u0026#39;T\u0026#39;: await websocket.send(\u0026#39;Conflict\u0026#39; if message[i]==\u0026#39;1\u0026#39; and message[j]==\u0026#39;1\u0026#39; else \u0026#39;OK\u0026#39;) 第三关 传送门：第三关。\n答案：纳。\n设计解法： 反编译 wasm 得到判断密码正确的算法。其原始 C 代码如下：\nint f(int g){ return g==0?0:g+f(g/2); } int checkPassword(int pwd){ return f(pwd)==64859?pwd:0; // 纳 32435 } 然后这里可以用遍历等方式获得 pwd 值为 32435，即“纳”的 utf-16 编码。\n暴力解法： 直接用 javascript 遍历可能的 unicode 值。\nfor(var i=0;i\u0026lt;100000;i++) if(checkpwd(i)) console.log(i); 得到32435, String.fromCharCode(32435) 得“纳”。\n第四关 传送门：第四关。\n答案：喜。\n提示是 esolang，即 “esoteric programming languages”。这里网页里实际上包括了一段 whitespace 代码，如下。\n转换成伪代码则是\npush 21915\rpush 1\radd\rend 即21916，喜的 UTF-16 编码。\n红包 根据主页的说明，红包口令即为对年纳喜20。\n","permalink":"http://localhost:1313/posts/2020/","summary":"\u003cp\u003e传送门：\u003ca href=\"https://harrynull.tech/2020/\"\u003e2020新年解谜\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e祝大家2020元旦快乐。以下是游戏的题解。\u003c/p\u003e","title":"2020 新年解谜答案"},{"content":"当我在玩 MakeCode 时候，无意间发现 EV3 的显示屏可以显示自定义图像并且支持发出声音……\nBad Apple!! 首先先下载 Bad Apple!! 视频并利用 ffmpeg 转换成 png 图片 (178*128 10fps)\nffmpeg -i bad_apple.mp4 -vf scale=178:128 -r 10 ba_%5d.png 第一步是想办法将图片放置到 EV3 里。由于 MakeCode 似乎不支持上传文件，并且对代码长度有最大限制，于是就必须想出一种压缩方式。 这里我选用的压缩方式是将每帧转换成黑白图片，并且转换成 u8 的数组 a，数组a[2n]代表接下来黑色像素点数量，a[2n+1]代表白色像素点数量。最后再用base64加密放入 MakeCode 代码中（其实应该也可以直接创建数字数组的，可能没必要用 base64）。\n压缩转换代码如下：\nimport base64 from PIL import Image def compress(filename): res=[] img = Image.open(filename) .convert(\u0026#39;L\u0026#39;).point(lambda x : 255 if x \u0026gt; 200 else 0, mode=\u0026#39;1\u0026#39;) pixels = list(img.getdata()) cnt=0 lst_color=0 # start from black for p in pixels: if lst_color==p: if cnt==255: # avoid overflow res.append(cnt) res.append(0) cnt=0 cnt+=1 else: lst_color=p res.append(cnt) cnt=1 res.append(cnt) return base64.b64encode(bytearray(res)).decode() 之后就简单了，直接在 EV3 上编码图片并显示即可：\ndata.forEach(function (f: string) { let myImage = image.create(178, 128); let decoded = new Base64().decode(f); let is_black = true; // start from black let x = 0; let y = 0; for (let i = 0; i \u0026lt; decoded.length; ++i) { let n = decoded.charCodeAt(i); for (let j = 0; j \u0026lt; n; ++j) { if (is_black) myImage.setPixel(x, y, 1); x++; if (x == 178) { x = 0; y++; } } is_black = !is_black; } brick.showImage(myImage); }); 吐槽一下，MakeCode 用的是阉割版的 TypeScript，很多 JavaScript 里的东西都不能用，导致 Base64 都要造轮子。 (此处应该有一个视频，但是由于太懒了就没弄)\n马里奥 做完 Bad Apple!! 之后发现 EV3 竟然支持 playTone(frequency, duration)，于是写了个简单的脚本转换 MIDI 文件成 MakeCode 代码。\nimport sys # From https://gist.github.com/YuxiUx/ef84328d95b10d0fcbf537de77b936cd def noteToFreq(note): a = 440 #frequency of A (coomon value is 440Hz) return (a / 32) * (2 ** ((note - 9) / 12)) # http://valentin.dasdeck.com/midi/mid2txt.php SPEED=1.04166666666667 #60000 / (BPM * PPQ) #music.playTone(659, 1013 - 512); #loops.pause(1536 - 1013) with open(\u0026#34;out.txt\u0026#34;, \u0026#34;w\u0026#34;) as out: with open(sys.argv[1]) as file: for line in file: #0 On ch=1 n=76 v=110 vals=line.split(\u0026#34; \u0026#34;) if len(vals)!=5: print(\u0026#34;[*] unrecognized line\u0026#34;, vals, \u0026#34;skipping...\u0026#34;) continue time, status, _, note, vol = vals time=int(time) if status!=\u0026#34;On\u0026#34; or time ==0 or vol==0:continue out.write(\u0026#34;music.playTone(%s, %d);\\n\u0026#34;%(noteToFreq(int(note[2:])), time/SPEED)); print(\u0026#34;[*] ok!\u0026#34;) ","permalink":"http://localhost:1313/posts/ev3/","summary":"\u003cp\u003e当我在玩 \u003ca href=\"https://makecode.mindstorms.com/#editor\"\u003eMakeCode\u003c/a\u003e 时候，无意间发现 EV3 的显示屏可以显示自定义图像并且支持发出声音……\u003c/p\u003e","title":"EV3 上放 Bad Apple!! 和马里奥"},{"content":"早就看首页单调的背景不爽了，这次趁着迁移网站的机会顺便造了一个随机获取和显示动漫壁纸的轮子。\n实现思路：从 /r/Animewallpaper 上爬墙带 Desktop flair 的帖子。 来源\n(效果图的壁纸来自 pixiv id 66568021 by 千夜QYS3)\n实现细节：\n从 https://www.reddit.com/r/Animewallpaper/search.rss?q=flair_name%3A%22Desktop%22\u0026restrict_sr=1 获取 RSS feed，解析获取前 25 条结果。该结果缓存 10 分钟。 def entry_to_dictionary(entry): return { \u0026#34;source\u0026#34;: entry.find(\u0026#34;{http://www.w3.org/2005/Atom}link\u0026#34;).attrib[\u0026#34;href\u0026#34;], \u0026#34;title\u0026#34;:entry.find(\u0026#34;{http://www.w3.org/2005/Atom}title\u0026#34;).text, \u0026#34;img\u0026#34;: RE_EXTRACT_IMG.search(entry.find(\u0026#34;{http://www.w3.org/2005/Atom}content\u0026#34;).text).groups(0)[0] } def fetch_feed(): global last_fetch_time global cached_results if time.time() - last_fetch_time \u0026lt;= CACHE_VALID_TIME and cached_results: return cached_results results = [] e = xml.etree.ElementTree.fromstring(requests.get(FEED_URL, headers={\u0026#34;User-Agent\u0026#34;:USER_AGENT}).text.strip()) for entry in e.findall(\u0026#34;{http://www.w3.org/2005/Atom}entry\u0026#34;): try: results.append(entry_to_dictionary(entry)) except: pass cached_results = results last_fetch_time = time.time() return results 前端通过ajax从/random_anime_wallpaper获取一份随机壁纸。\n为了优化国内用户的加载速度，考虑在服务端获取壁纸后直接发给用户（相当于一个反代）。\n一开始打算用 base64 编码壁纸然后丢在 json 里返回。然而这么实现的话客户端要下载完整张图片才能渲染显示。除此以外，由于使用了 gunicorn，每个 worker 的缓存都是独立的，也非常浪费内存。 故打算在服务端下载到硬盘，并直接返回静态路径，这样只有在第一次调用 API 的时候会稍有延迟。实现如下： def download_img(src): ext = src.split(\u0026#34;.\u0026#34;)[-1] name = \u0026#34;static/\u0026#34; + hashlib.sha1(src.encode()).hexdigest() + \u0026#34;.\u0026#34; + ext if os.path.isfile(name): return name print(\u0026#34;Downloading \u0026#34;, src, \u0026#34; to \u0026#34;, name) with open(name, \u0026#39;wb\u0026#39;) as f: f.write(requests.get(src).content) return name @app.route(\u0026#34;/random_anime_wallpaper\u0026#34;) def random_anime_wallpaper(): res = fetch_feed() selected = copy.deepcopy(res[random.randint(0, len(res))]) if request.args.get(\u0026#39;download\u0026#39;, False): selected[\u0026#34;img_src\u0026#34;] = selected[\u0026#34;img\u0026#34;] selected[\u0026#34;img\u0026#34;] = URL_BASE_PATH + download_img(selected[\u0026#34;img\u0026#34;]) return jsonify(selected) 最后直接使用 nginx 反代请求到 python 上就可以了：\nlocation /api/wallpapers/ { proxy_pass http://127.0.0.1:8001/; } 从思路到实现都非常简单~\nDemo | API | Source\n","permalink":"http://localhost:1313/posts/random-anime-wallpaper/","summary":"\u003cp\u003e早就看首页单调的背景不爽了，这次趁着迁移网站的机会顺便造了一个随机获取和显示动漫壁纸的轮子。\u003c/p\u003e\n\u003cp\u003e实现思路：从 \u003ca href=\"https://www.reddit.com/r/Animewallpaper/\"\u003e/r/Animewallpaper\u003c/a\u003e 上爬墙带 \u003ccode\u003eDesktop\u003c/code\u003e flair 的帖子。 \u003ca href=\"https://www.reddit.com/r/anime/comments/5ec91v/any_api_for_anime_wallpapers/dad0kt9/\"\u003e来源\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e(效果图的壁纸来自 \u003ca href=\"https://www.pixiv.net/member_illust.php?mode=medium\u0026illust_id=66568021\"\u003epixiv id 66568021 by 千夜QYS3\u003c/a\u003e)\u003c/p\u003e","title":"随机动漫壁纸 API"},{"content":"Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于我好久没写 C++ 了，于是突然一时兴起想要造一个 Base64 编解码的轮子。\n转换的时候，将3字节的数据，先后放入一个24位的缓冲区中，先来的字节占高位。数据不足3字节的话，于缓冲器中剩下的比特用0补足。每次取出6比特，按照其值选择ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/中的字符作为编码后的输出，直到全部输入数据转换完成。若原数据长度不是3的倍数时且剩下1个输入数据，则在编码结果后加2个=；若剩下2个输入数据，则在编码结果后加1个=。\n以上是摘自维基百科Base64的 Base64 编码方式。\n首先在实现编解码之前先定义 base64 字符。\nconstexpr char base64_char[] = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34;; 编码 首先先实现编码函数：\nstring base64_encode(const char* src, size_t len) { string ret = \u0026#34;\u0026#34;; ret.reserve(len * 4 / 3); // base64编码长度大概是原来的4/3 for (size_t i = 0; i \u0026lt; len; i += 3) { // 每三个byte处理一次 char first = src[i]; char second = i + 1 \u0026lt; len ? src[i + 1] : 0; char third = i + 2 \u0026lt; len ? src[i + 2] : 0; ret += base64_char[(first \u0026gt;\u0026gt; 2) \u0026amp; 0b111111]; // 1st high 6 bits ret += base64_char[(first \u0026amp; 0b11) \u0026lt;\u0026lt; 4 | ((second \u0026gt;\u0026gt; 4) \u0026amp; 0b1111)]; // 1st low 2 bits + 2nd high 4 bits if (i + 1 \u0026gt;= len) { ret += \u0026#34;==\u0026#34;; break; } ret += base64_char[(second \u0026amp; 0b1111) \u0026lt;\u0026lt; 2 | ((third \u0026gt;\u0026gt; 6) \u0026amp; 0b11)]; // 2nd low 4 bits + 3rd high 2 bits if (i + 2 \u0026gt;= len) { ret += \u0026#34;=\u0026#34;; break; } ret += base64_char[third \u0026amp; 0b111111]; // 3rd low 6 bits } return ret; } 需要注意的是位运算的处理方式： (first \u0026amp; 0b11) \u0026lt;\u0026lt; 4 | ((second \u0026gt;\u0026gt; 4) \u0026amp; 0b1111) 这一个表达式将first的最后2bits和second的高4bits连在了一起。需要注意的是\u0026gt;\u0026gt;运算符在某些编译器下（implementation-defined）可能会导致执行arithmetic shift而不是logical shift。这就会导致0b11110000\u0026gt;\u0026gt;1的结果有可能是0b11111000（移位时复制最高位）。因此，在这个操作后要手动\u0026amp; 0b1111一下。\n解码 然后再来实现解码函数。解码函数基本上就是编码的逆向过程。\n首先先定义一个base64_char_convert函数用来将base64字符转换成原始byte。以下是一个最简单的实现。出于效率考虑还可以把这个函数实现成查表。\nstruct InvalidBase64 {}; char base64_char_convert(char c) { for (size_t i = 0; i \u0026lt; sizeof(base64_char); ++i) if (base64_char[i] == c) return i; throw InvalidBase64(); // Invalid base64 character } 然后再实现真正的解码函数：\nvector\u0026lt;char\u0026gt; base64_decode(const string\u0026amp; src) { vector\u0026lt;char\u0026gt; ret; ret.reserve(src.length() * 3 / 4); for (size_t i = 0; i \u0026lt; src.length(); i += 4) { char b1 = base64_char_convert(src[i]); char b2 = base64_char_convert(src[i + 1]); ret.push_back((b1 \u0026lt;\u0026lt; 2) | ((b2 \u0026gt;\u0026gt; 4 \u0026amp; 0b11))); // 1st 6bits, 2nd high 2bits if (src[i + 2] == \u0026#39;=\u0026#39;) break; char b3 = base64_char_convert(src[i + 2]); ret.push_back(((b2 \u0026amp; 0b1111) \u0026lt;\u0026lt; 4) | ((b3 \u0026gt;\u0026gt; 2) \u0026amp; 0b1111)); // 2nd low 4bits, 3rd high 4bits if (src[i + 3] == \u0026#39;=\u0026#39;) break; char b4 = base64_char_convert(src[i + 3]); ret.push_back(((b3 \u0026amp; 0b11) \u0026lt;\u0026lt; 6) | b4); // 3rd low 2bits, 4th 6bits } return ret; } 测试 最后，写一个主程序测试一下以上代码吧。\nstring bytes_to_string(const vector\u0026lt;char\u0026gt;\u0026amp; v) { return string(v.begin(), v.end()); } #define STR_AND_LEN(c_str) c_str, (sizeof(c_str)-1) int main() { string a, b, c; cout \u0026lt;\u0026lt; (a = base64_encode(STR_AND_LEN(\u0026#34;hi, base64!\u0026#34;))) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; (b = base64_encode(STR_AND_LEN(\u0026#34;hii, base64!\u0026#34;))) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; (c = base64_encode(STR_AND_LEN(\u0026#34;hello, base64!\u0026#34;))) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; (bytes_to_string(base64_decode(a))) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; (bytes_to_string(base64_decode(b))) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; (bytes_to_string(base64_decode(c))) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; base64_encode(STR_AND_LEN( \u0026#34;Man is distinguished, not only by his reason, but by this singular passion \u0026#34; \u0026#34;from other animals, which is a lust of the mind, that by a perseverance of \u0026#34; \u0026#34;delight in the continued and indefatigable generation of knowledge, exceeds \u0026#34; \u0026#34;the short vehemence of any carnal pleasure.\u0026#34;))\u0026lt;\u0026lt;endl; cout \u0026lt;\u0026lt; (bytes_to_string(base64_decode( \u0026#34;TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlz\u0026#34; \u0026#34;IHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2Yg\u0026#34; \u0026#34;dGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGlu\u0026#34; \u0026#34;dWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRo\u0026#34; \u0026#34;ZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=\u0026#34;))) \u0026lt;\u0026lt; endl; } 运行结果：\naGksIGJhc2U2NCE=\raGlpLCBiYXNlNjQh\raGVsbG8sIGJhc2U2NCE=\rhi, base64!\rhii, base64!\rhello, base64!\rTWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=\rMan is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure. ","permalink":"http://localhost:1313/posts/base64/","summary":"\u003cp\u003eBase64是一种基于64个可打印字符来表示二进制数据的表示方法。由于我好久没写 C++ 了，于是突然一时兴起想要造一个 Base64 编解码的轮子。\u003c/p\u003e","title":"用C++实现base64编解码"},{"content":" Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.\n这是来自 leetcode 的一道经典题目——不使用+实现求和。本文将从整数（有符号和无符号）在内存的表现入手并讨论该题解法。\n以上是有无符号整数的公式化表示，截图自CMU 15-213讲座视频，其中w表示该数在内存中占的bit数。\n首先先了解有无符号整数的表示方法和他们的最大最小值。\n无符号整数 先从最简单的无符号整数开始，以下是一个无符号整数(8bit)的二进制表示的例子。\n# 8 7 6 5 4 3 2 1 值 128 64 32 16 8 4 2 1 二进制 0 1 1 0 0 1 0 0 x= 0 64 32 0 0 4 0 0 Sum 100 以上是无符号整数二进制01100100的十进制值求法。从其最小位开始，设第一位值1，第二位值2……第n位值2^n。然后做一个简单的求和即可算出来其十进制值。 用 Windows 10 自带的计算器验证结果（BIN 0110 0100 == DEC 100）。\n我们可以由上表推算出8位二进制可以表示的最大无符号数为0b1111 1111，即2^0+2^1+2^2+\u0026hellip;+2^7=255；最小值当然就是0b0000 0000，即十进制0。\n有符号整数（补码） 在“补码”表示的有符号整数中，人们规定把二进制的MSB(most significant bit)，即最后一位规定为符号位，具体表现是这样的：\n# 8 7 6 5 4 3 2 1 值 -128 64 32 16 8 4 2 1 二进制 0 1 1 0 0 1 0 0 x= 0 64 32 0 0 4 0 0 Sum 100 注意最后一位的“价值”从128变成了-128，而其它各位的“价值”保持不变，这样就在一定程度上保持了有无符号数内存表示的兼容。\n由此表可得，有符号数字的最大值是0b0111 1111（除了-128的一位其它位都选上），即127，如下表所示：\n#|8|7|6|5|4|3|2|1 :\u0026mdash;\u0026ndash;:|:\u0026mdash;\u0026ndash;:|:\u0026mdash;\u0026ndash;:|:\u0026mdash;\u0026ndash;:|:\u0026mdash;\u0026ndash;:|:\u0026mdash;\u0026ndash;:|:\u0026mdash;\u0026ndash;:|:\u0026mdash;\u0026ndash;:| 值|-128|64|32|16|8|4|2|1 二进制|0|1|1|1|1|1|1|1 x=|0|64|32|16|8|4|2|1 Sum|127\n而有符号整数的最小值则为0b1000 0000（只选择-128这个负数“价值”的位），即-128：\n# 8 7 6 5 4 3 2 1 值 -128 64 32 16 8 4 2 1 二进制 1 0 0 0 0 0 0 0 x= -128 0 0 0 0 0 0 0 Sum -128 ∴8bit有符号整数的范围为-128~127\n加法 二进制的加法其实就和十进制加法一样，列个竖式算个进位就出来了。比如说0b0010 0001 + 0b0001 0111:\n0b 0010 0001 (33) + 0b 0001 0111 (23) = 0b 0011 1000 (56) 有趣的是，相同的规则也能运用到有符号整数中，例如：\n0b 1010 0001 (-95) + 0b 0001 0111 (23) = 0b 1011 1000 (-72) （所以说其实根本不需要知道补码是什么的吗(╯‵□′)╯︵┻━）） 那么我们只要写程序模拟这个竖式加法过程就可以了。 在此之前先介绍一下异或运算符(^)，其运算过程如下：\nA B A^B 0 0 0 0 1 1 1 0 1 1 1 0 可以看到异或运算和加法运算很像，我们可以利用该运算符来模拟加法，然后只要手动处理进位就可以了。\n#include \u0026lt;iostream\u0026gt; int add(int a, int b) { // a+b int sum = 0; constexpr size_t intLength = sizeof(int) * 8; bool lcarry = false; for (size_t i = 0; i \u0026lt; intLength; ++i) { bool carry = false; // 这一位是否会产生进位 int mask = 1 \u0026lt;\u0026lt; i; // 指定我们正在处理的位数 bool val = (a\u0026amp;mask) ^ (b\u0026amp;mask); // 这一位的运算结果 if ((a\u0026amp;mask) \u0026amp;\u0026amp; (b\u0026amp;mask)) carry = true; // 如果两个加数这一位都是1的话就会产生进位 if (lcarry) { // 上一位有进位吗? if (val) carry = true; // 如果上一位有进位，这一位是1的话，那这一位也会产生进位 val ^= 1; // 不然的话就加一 } lcarry = carry; if (val) sum |= mask; // 设置这一位的运算结果 } return sum; } int main(){ int a, b; std::cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; std::cout \u0026lt;\u0026lt; add(a, b) \u0026lt;\u0026lt; std::endl; } 这样我们就花了16行实现了a+b。 然而，可能你也发现了，这样实现其实在for循环里还是有一个++运算的orz 不过幸好这个加号很容易就可以去掉——我们只需要手动展开循环就可以了（逃\n好吧其实还有更优雅的方式，我们可以一次性把所有位数全部运算一遍！优化过的代码如下：\n#include \u0026lt;iostream\u0026gt; int add(int a, int b) { int carry=(a\u0026amp;b)\u0026lt;\u0026lt;1; int sum=a^b; while (carry!=0){ // 一直加到没有进位为止 int newSum=sum^carry; // 加进位 carry=(sum\u0026amp;carry)\u0026lt;\u0026lt;1; // 获取加进位的时候可能产生的进位 sum=newSum; } return sum; } int main(){ int a, b; std::cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; std::cout \u0026lt;\u0026lt; add(a, b) \u0026lt;\u0026lt; std::endl; } ","permalink":"http://localhost:1313/posts/ab-problem/","summary":"\u003cblockquote\u003e\n\u003cp\u003eCalculate the sum of two integers a and b, but you are not allowed to use the operator + and -.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e这是来自 leetcode 的一道经典题目——不使用+实现求和。本文将从整数（有符号和无符号）在内存的表现入手并讨论该题解法。\u003c/p\u003e","title":"不用+实现A+B Problem"},{"content":"在靠写 txt 和 uptime bot 来记录统计数据和监测服务可用性一年后，终于趁着这次 docker 化服务的时候下定决心用一套像样的监控系统。\n选定的方案：\nGrafana 用于可视化数据 Graphite 用于汇总数据 collectd 用来收集系统/apache数据 statsd 用来收集自定义服务数据 数据结构图： statsd, collectd -\u0026gt; graphite -\u0026gt; grafana\n以上框架均使用docker部署（如果可用的话）\n1. 部署 graphite 用来汇总数据 graphite 还是很好配置的，直接使用现成的 docker 镜像即可，里面还自带了 statsd：graphite-project/docker-graphite-statsd。\n比较坑的地方是给 graphite 的 dashboard 添加密码，官方的那个镜像好像默认是不支持密码保护的。除了换用 sitespeedio/docker-graphite-statsd 的 fork 就只能手动给 nginx 添加密码了，最好的方法当然是自己 fork 一个改一下，偷懒的方法如下：\ndocker exec -it graphite bash 进入 container 的 bash\nvim /etc/nginx/.htpasswd 添加用户名和密码（可以用在线生成器或者htpasswd工具生成）。\nvim /etc/nginx/sites-enabled/graphite-statsd.conf 在 location / 块中添加以下两行\nauth_basic \u0026ldquo;Auth needed\u0026rdquo;; auth_basic_user_file /etc/nginx/.htpasswd;\nnginx -s reload 使修改生效\n最后别忘了修改网页控制台的root密码\nUpdate the default Django admin user account. The default is insecure. username: root password: root email: root.graphite@mailinator.com First login at: http://localhost/account/login Then update the root user\u0026rsquo;s \u0026gt; profile at: http://localhost/admin/auth/user/1/\n2. 部署 Grafana 用于可视化数据 送分题，看官方 docker 教程即可。 例子：\ndocker run \\ -d \\ -p 3000:3000 \\ --name=grafana \\ -e \u0026#34;GF_INSTALL_PLUGINS=grafana-piechart-panel\u0026#34; \\ grafana/grafana 3. collectd 用来收集系统/apache数据 collectd 可以在 host 和 container 里安装 先预先改好 collectd.conf 文件，要改的地方主要是Hostname，LoadPlugin write_graphite, write_graphite 块的配置。我在这里还额外开启了 apache 插件来监测 apache 数据（修改LoadPlugin apache和 apache 块的配置）。\n然后在 Dockerfile 里添加：\nRUN apt-get install -q -y collectd ARG HOSTNAME_PLACEHOLDER ARG GRAPHITE_HOST COPY conf/collectd.conf /etc/collectd/collectd.conf RUN sed -i \u0026quot;s/HOSTNAME_PLACEHOLDER/${NAME}/g\u0026quot; /etc/collectd/collectd.conf RUN sed -i \u0026quot;s/GRAPHITE_HOST_PLACEHOLDER/${GRAPHITE_HOST}/g\u0026quot; /etc/collectd/collectd.conf 比较坑的一点是 collectd 服务默认是不启动的，所以要手动指定一下：\nCMD service collectd start \u0026amp;\u0026amp; apache2-foreground 此外，如果选择监测 apache 的话，还需要额外对 apache 进行配置 （只允许localhost访问）：\nRUN echo \u0026quot;ExtendedStatus on\u0026quot; \u0026gt;\u0026gt; /etc/apache2/apache2.conf \u0026amp;\u0026amp;\\ echo \u0026quot;\u0026lt;Location /mod_status\u0026gt;\u0026quot; \u0026gt;\u0026gt; /etc/apache2/apache2.conf \u0026amp;\u0026amp;\\ echo \u0026quot; SetHandler server-status\u0026quot; \u0026gt;\u0026gt; /etc/apache2/apache2.conf \u0026amp;\u0026amp;\\ echo \u0026quot; Deny from all\u0026quot; \u0026gt;\u0026gt; /etc/apache2/apache2.conf \u0026amp;\u0026amp;\\ echo \u0026quot; Allow from localhost ip6-localhost\u0026quot; \u0026gt;\u0026gt; /etc/apache2/apache2.conf \u0026amp;\u0026amp;\\ echo \u0026quot;\u0026lt;/Location\u0026gt;\u0026quot; \u0026gt;\u0026gt; /etc/apache2/apache2.conf 4. 部署 statsd 用来收集自定义服务数据 实际上 statsd 已经在部署 graphite 的时候一起部署过了，这里做的实际上是配置服务来提交数据。\n由于我的服务是 php 写的，所以我是直接选用的 domnikl/statsd-php 框架来进行整合。\n5. 搭建 Dashboard 终于到最后一步辣。打开之前部署的 Grafana 控制台然后根据自己的需求添加数据源和图表，打造炫酷的 Dashboard（尽管用户看不到）。\n别忘了修改 Grafana 的密码哦。\n最终成品图：\n","permalink":"http://localhost:1313/posts/server-monitor/","summary":"\u003cp\u003e在靠写 txt 和 uptime bot 来记录统计数据和监测服务可用性一年后，终于趁着这次 docker 化服务的时候下定决心用一套像样的监控系统。\u003c/p\u003e\n\u003cp\u003e选定的方案：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eGrafana 用于可视化数据\u003c/li\u003e\n\u003cli\u003eGraphite 用于汇总数据\u003c/li\u003e\n\u003cli\u003ecollectd 用来收集系统/apache数据\u003c/li\u003e\n\u003cli\u003estatsd 用来收集自定义服务数据\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e数据结构图： statsd, collectd -\u0026gt; graphite -\u0026gt; grafana\u003c/p\u003e\n\u003cp\u003e以上框架均使用docker部署（如果可用的话）\u003c/p\u003e","title":"部署基于 Grafana + Graphite + collectd + statsd 的服务监控系统"},{"content":"为什么一般文件夹下的文件不允许重名，而回收站里的允许？\n当一个文件被删除之后，Windows 将会自动将其重命名之后再放到一个自己维护的一个文件夹结构里去（即X:$Recycle.Bin），如下图：\n回收站的实际文件结构\n因此，在 Windows Explorer 下看起来是同名的文件，在回收站的文件系统中实际存储的文件名不重复。\n那么，这些像是乱码的文件名到底是什么意思呢？Windows 是怎么通过这些文件名还原出这些文件原来的名字，路径的呢？\n举一个文件作为例子：\nC:\\$Recycle.Bin\\S-1-5-21-XXXXXXXXXX-XXXXXXXXXX-XXXXXXXXXX-1001\\$RGL5JR1.exe C:\\$Recycle.Bin\\S-1-5-21-XXXXXXXXXX-XXXXXXXXXX-XXXXXXXXXX-1001\\$IGL5JR1.exe 其中 C:$Recycle.Bin\\ 即为回收站的路径，每个盘都有一个回收站。\n文件夹\u0026quot;S-1-5-21-XXXXXXXXXX-XXXXXXXXXX-XXXXXXXXXX-1001\u0026quot;是 SID，Windows 系统中用来辩识一个实体的辩识符，比如一个用户或是一个组。这样做的原因是为了进行权限控制，来避免一个普通用户（非管理员）可以查看、读取或删除其它用户的回收站文件。\n再来看文件名，可能你也发现了，说是一个文件，实际上在回收站中每删除一个文件都会产生两个文件，这两个文件具有相同的后缀和ID，唯一的区别是它们的前缀不同——一个是 \u0026ldquo;$I\u0026rdquo; 开头而另一个是 \u0026ldquo;$R\u0026rdquo; 开头。$R 开头的文件中存储着文件的实际内容，而$I 前缀的文件存储着这个文件在被你丢进回收站之前的文件名，路径，时间等信息。尽管没有办法证实，但是你可以猜测R代表 Recycled，而 I 代表 Information。\n\u0026ldquo;$I\u0026rdquo; 开头这个文件是用二进制存储的，用 hexdump 输出文件内容如下：\n$ hexdump -e \u0026#39;16/1 \u0026#34;%02X \u0026#34; \u0026#34; | \u0026#34;\u0026#39; -e \u0026#39;16/1 \u0026#34;%_p\u0026#34; \u0026#34;\\n\u0026#34;\u0026#39; \u0026#34;\\$IGL5JR1.exe\u0026#34; 02 00 00 00 00 00 00 00 88 13 16 00 00 00 00 00 | ................ D0 A3 78 2A 9A D3 D3 01 27 00 00 00 43 00 3A 00 | ..x*....\u0026#39;...C.:. 5C 00 55 00 73 00 65 00 72 00 73 00 5C 00 4E 00 | \\.U.s.e.r.s.\\.N. 75 00 6C 00 6C 00 5C 00 44 00 6F 00 77 00 6E 00 | u.l.l.\\.D.o.w.n. 6C 00 6F 00 61 00 64 00 73 00 5C 00 53 00 74 00 | l.o.a.d.s.\\.S.t. 65 00 61 00 6D 00 53 00 65 00 74 00 75 00 70 00 | e.a.m.S.e.t.u.p. 2E 00 65 00 78 00 65 00 00 00 | ..e.x.e... 其中，第一行的 88 13 16 00 00 00 00 00 即为被删除文件的大小，0x161388 转换为10进制即为1446792（单位Byte）或约1412.9 KB / 1.3 MB。\n第二行保存的是被删除文件的删除日期 D0 A3 78 2A 9A D3 D3 01。0x1D3D39A2A78A3D0 转换为10进制是131681473214850000，这是自从1601年1月1日开始算的100纳秒的个数。利用系统自带的小工具我们可以将其转换成正常可读的时间：\nD:\\\u0026gt;w32tm.exe /ntte 131681473214850000 152409 02:42:01.4850000 - 18/4/14 10:42:01 剩下来的部分即为被删除文件的原来的路径：C:\\Users\\Null\\Downloads\\SteamSetup.exe\n所以我们/操作系统就可以得知，这原来是个我 (用户Null) 在 18/4/14 10:42:01 删除的一个大小为1446792 Bytes 的位于 C:\\Users\\Null\\Downloads\\ 文件名为 SteamSetup.exe 的文件。\n打开回收站验证 参考文章：https://pdfs.semanticscholar.org/db62/a02a2f90c569200bf37ead369221e04393d8.pdf\n（其实我几乎就是翻译+验证了一下这个文章）\n此文章是搬运我在知乎上的回答：https://www.zhihu.com/question/272210371/answer/367326483\n","permalink":"http://localhost:1313/posts/windows-recycle/","summary":"\u003cp\u003e\u003ca href=\"https://www.zhihu.com/question/272210371/answer/367326483\"\u003e为什么一般文件夹下的文件不允许重名，而回收站里的允许？\u003c/a\u003e\u003c/p\u003e","title":"Windows 回收站的原理"},{"content":"众所周知（划掉），UTF-8是一种可变长度字符编码，即每个字符会占用不等数量(1-4个)的byte。例如，一个英文字母只占用1个byte，而大部分汉字需要2个byte来储存。\n因此，传统的strlen（统计字符串byte数量）来获取字符数的方式就变得不准确了。这就是为什么某些网站输入框会把一个汉字误认为是两个字的原因。\n那么，应该如何正确判断字符数量呢？UTF-8遵循以下编码规则：\nBinary Hex Comments 0xxxxxxx 0x00..0x7F Only byte of a 1-byte character encoding 10xxxxxx 0x80..0xBF Continuation bytes (1-3 continuation bytes) 110xxxxx 0xC0..0xDF First byte of a 2-byte character encoding 1110xxxx 0xE0..0xEF First byte of a 3-byte character encoding 11110xxx 0xF0..0xF4 First byte of a 4-byte character encoding （摘自 How many bytes does one Unicode character take?）\n可见，有两种获取字符数的方法：一个是通过第一个byte中前X个是1来判断这个字符一共有几个byte，另一个是直接忽略掉10开头的字符。显然，后者比较容易实现。\nsize_t count_character(char* raw_string) { size_t character_counter = 0; for (char* ptr = raw_string; *ptr != \u0026#39;\\0\u0026#39;; ptr++) { if ((((*ptr) \u0026gt;\u0026gt; 6) \u0026amp; 0b11) == 0b10) continue; character_counter++; } return character_counter; } 测试程序：\nint main() { char raw_string[] = { \u0026#34;你好, 世界!\u0026#34; }; std::cout \u0026lt;\u0026lt; \u0026#34;strlen: \u0026#34; \u0026lt;\u0026lt; strlen(raw_string) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;count_character: \u0026#34; \u0026lt;\u0026lt; count_character(raw_string) \u0026lt;\u0026lt; std::endl; } 输出：\nstrlen: 15 count_character: 7 写了好久了，一直懒得发上来（\n","permalink":"http://localhost:1313/posts/utf8-strlen/","summary":"\u003cp\u003e众所周知（划掉），UTF-8是一种可变长度字符编码，即每个字符会占用不等数量(1-4个)的byte。例如，一个英文字母只占用1个byte，而大部分汉字需要2个byte来储存。\u003c/p\u003e\n\u003cp\u003e因此，传统的strlen（统计字符串byte数量）来获取字符数的方式就变得不准确了。这就是为什么某些网站输入框会把一个汉字误认为是两个字的原因。\u003c/p\u003e","title":"判断UTF-8字符数"},{"content":"“顺时针阅读法(The Clockwise/Spiral Rule)”是一种很简单方便的用来解析c中复杂类型的方法。\n用int(*((*ptr(int,int))))(int);作为例子： 先从ptr 是……开始： 从ptr开始，向右阅读，遇到(int,int)，说明ptr是一个函数，接受参数(int,int)。 ptr 是 一个函数 接受(int,int) 返回……\n然后转到左边，遇到*，代表ptr的返回值是个指针。\nptr 是 一个函数 接受(int,int) 返回 一个指针，指向……\n目前的情况大概是：\nint(*((ptr)))(int); 去掉两对括号后：\nint(*ptr)(int); 右边遇到)，再到左边，遇到了*，代表这又是个指针。现在我们有：\nptr 是 一个函数 接受(int,int) 返回 一个指针，指向 一个指针 指向……\n再向右，遇到(int)，代表接下来是一个函数。现在有：\nptr 是 一个函数 接受(int,int) 返回 一个指针，指向 一个指针 指向 一个函数 接受(int) 返回……\n再转一圈，遇到最后的int。完整的ptr的类型是：\nptr 是 一个函数 接受(int,int) 返回 一个指针，指向 一个指针 指向 一个函数 接受(int) 返回int\n或者可以换一个语序：\nptr 是 一个接受(int,int)返回(一个指向(一个指向(一个接受(int)返回int的函数)的指针)的指针)的函数\n构造一段代码来测试一下这个结果：\nint foo(int){return 0;} //一个接受(int)返回int的函数 decltype(\u0026amp;foo) address_of_foo=\u0026amp;foo; //一个指向(一个接受(int)返回int的函数)的指针 int(*((*ptr(int,int))))(int) { //一个接受(int,int) 返回(一个指向(一个指向(一个接受(int)返回int的函数)的指针)的指针)的函数 return \u0026amp;address_of_foo; //一个指向(一个指向(一个接受(int)返回int的函数)的指针)的指针 } 那么怎么才能把这个转换成一般人能读懂的代码呢，其实加一个alias就可以大大增强可读性：\nusing FuncType = int(int); FuncType** ptr2(int,int); 简单易懂。\n本文原写为知乎某问题的答案。\n","permalink":"http://localhost:1313/posts/read-c-function/","summary":"\u003cp\u003e“顺时针阅读法(\u003ca href=\"http://c-faq.com/decl/spiral.anderson.html\"\u003eThe Clockwise/Spiral Rule\u003c/a\u003e)”是一种很简单方便的用来解析c中复杂类型的方法。\u003c/p\u003e","title":"解析int(*((*ptr(int,int))))(int);"},{"content":"驱动下载 先到下载并安装CDLoader。 如果没有光驱的电脑打开后应该是上图这样的界面，点击确定后，就关闭了。\n模拟光驱 由于软件只能读取Audio CD(cue/dat)，所以首先需要先用其它软件（例如UltraISO）制作出一个Audio CD出来。接着，再使用工具（如DAEMON Tools Lite）模拟光驱。\n最后，再按照提示操作即可将音频文件拷贝到电子词典上了。\n","permalink":"http://localhost:1313/posts/casio/","summary":"驱动下载 先到下载并安装CDLoader。 如果没有光驱的电脑打开后应该是上图这样的界面，点击确定后，就关闭了。\n模拟光驱 由于软件只能读取Audio CD(cue/dat)，所以首先需要先用其它软件（例如UltraISO）制作出一个Audio CD出来。接着，再使用工具（如DAEMON Tools Lite）模拟光驱。\n最后，再按照提示操作即可将音频文件拷贝到电子词典上了。","title":"给Casio电子词典拷歌"},{"content":"上次做lab2的时候看到了\ntest %eax,%eax je 400ef7 第一次看到这个代码的时候我下意识以为这就是jmp了，毕竟eax和eax比较当然相等辣。后来想想，编译器既然会生成这种代码肯定是有原因的。\n我先在 Intel® 64 and IA-32 Architectures Software Developer’s Manual 中查到了这几个指令： je:\n74 cb JE: Jump short if equal (ZF=1).\njne:\n75 cb JNE: Jump short if not equal (ZF=0).\ntest:\nOperation: TEMP ← SRC1 AND SRC2; SF ← MSB(TEMP); IF TEMP = 0 THEN ZF ← 1; ELSE ZF ← 0; FI: PF ← BitwiseXNOR(TEMP[0:7]); CF ← 0; OF ← 0; (* AF is undefined *)\n可以看出test %eax %eax之后，ZF=(SRC1\u0026amp;SRC2==0)\n由于SRC1和SRC2都是同一个eax，那么当eax==0时，ZF=1，触发JE；当eax!=0的时候，ZF=0，触发JNE。\n所以这一段其实是等价于if(!eax) jmp 0x400ef7;，而不是无条件跳转。\n","permalink":"http://localhost:1313/28.html","summary":"\u003cp\u003e上次做lab2的时候看到了\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-asm\" data-lang=\"asm\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003etest\u003c/span\u003e   \u003cspan class=\"nv\"\u003e%eax\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"nv\"\u003e%eax\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003eje\u003c/span\u003e     \u003cspan class=\"mi\"\u003e400\u003c/span\u003e\u003cspan class=\"no\"\u003eef7\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e第一次看到这个代码的时候我下意识以为这就是jmp了，毕竟eax和eax比较当然相等辣。后来想想，编译器既然会生成这种代码肯定是有原因的。\u003c/p\u003e","title":"test %eax %eax 是什么"},{"content":"介绍：这是一个“拆弹”游戏，玩家要在反汇编中找到每一关的拆弹密码，一共有6个phases。 该Lab的下载地址：http://csapp.cs.cmu.edu/3e/labs.html。\n警告：本文含有剧透内容，想要玩Lab2的慎看！\n`` 惯例先看代码：\n0000000000401062 \u0026lt;phase_5\u0026gt;: 401062: push %rbx 401063: sub $0x20,%rsp 401067: mov %rdi,%rbx 40106a: mov %fs:0x28,%rax 401073: mov %rax,0x18(%rsp) 401078: xor %eax,%eax 40107a: callq 40131b \u0026lt;string_length\u0026gt; 40107f: cmp $0x6,%eax 401082: je 4010d2 \u0026lt;phase_5+0x70\u0026gt; 401084: callq 40143a \u0026lt;explode_bomb\u0026gt; 401089:\tjmp 4010d2 \u0026lt;phase_5+0x70\u0026gt; 40108b: movzbl (%rbx,%rax,1),%ecx 40108f: mov %cl,(%rsp) 401092: mov (%rsp),%rdx 401096:\tand $0xf,%edx 401099: movzbl 0x4024b0(%rdx),%edx 4010a0: mov %dl,0x10(%rsp,%rax,1) 4010a4: add $0x1,%rax 4010a8: cmp $0x6,%rax 4010ac: jne 40108b \u0026lt;phase_5+0x29\u0026gt; 4010ae: movb $0x0,0x16(%rsp) 4010b3: mov $0x40245e,%esi 4010b8: lea 0x10(%rsp),%rdi 4010bd: callq 401338 \u0026lt;strings_not_equal\u0026gt; 4010c2: test %eax,%eax 4010c4: je 4010d9 \u0026lt;phase_5+0x77\u0026gt; 4010c6: callq 40143a \u0026lt;explode_bomb\u0026gt; 4010cb: nopl 0x0(%rax,%rax,1) 4010d0: jmp 4010d9 \u0026lt;phase_5+0x77\u0026gt; 4010d2: mov $0x0,%eax 4010d7: jmp 40108b \u0026lt;phase_5+0x29\u0026gt; 4010d9:\tmov 0x18(%rsp),%rax 4010de:\txor %fs:0x28,%rax 4010e7:\tje 4010ee \u0026lt;phase_5+0x8c\u0026gt; 4010e9:\tcallq 400b30 \u0026lt;__stack_chk_fail@plt\u0026gt; 4010ee:\tadd $0x20,%rsp 4010f2:\tpop %rbx 4010f3:\tretq 这段汇编出现了一堆之前没见过的操作，比如开头的mov %fs:0x28,%rax，经过查询后是用来进行stack-guard check的，详见这个回答。 无视掉那些奇怪的操作以后，转换成伪c语言大约是这样：\nrbx=rdi; //input *(rsp+18)=rax; eax=string_length(rdi); if(eax==6)goto 4010d2; explode_bomb(); goto 4010d2; 40108b: ecx=*(rbx+rax); *rsp=cl; //cx低8bit rdx=*rsp; edx=edx \u0026amp; 0xf edx=*(0x4024b0+rdx); *(rsp+rax+0x10)=dl; //dx低8bit rax++; if(rax!=0x6) goto 40108b; *(rsp+0x16)=0; if(!strings_not_equal(rsp+0x10,*0x40245e)) goto 4010d9; explode_bomb(); goto 4010d9; 4010d2: eax=0; goto 40108b; 4010d9: rax=*(rsp+18) 经过简单的分析和整理，可得：\nrbx=rdi; //input rax=string_length(rdi); assert(rax==6); rax=0; for(rax=0;rax!=0x6;rax++){ *rsp=rbx[rax]; *(rsp+rax+0x10)=(*(\u0026#34;maduiersnfotvbyl\u0026#34;+((*rsp)%16))); } *(rsp+0x16)=0; assert(!strings_not_equal(rsp+0x10,\u0026#34;flyers\u0026#34;)); 所以这段程序其实就是读入一个6个字符的字符串，对每个字符%16，然后映射到\u0026quot;maduiersnfotvbyl\u0026quot;这16个字符中用来构成\u0026quot;flyers\u0026quot;。 所以只要把9 15 14 5 6 7加16直到变成一个可以输入的字符即可。 用Python写一个脚本来找：\n\u0026gt;\u0026gt;\u0026gt; [\u0026#34;\u0026#34;.join([chr(c+i*16) for c in [9,15,14,5,6,7]]) for i in range(0,10)] [\u0026#39;\\t\\x0f\\x0e\\x05\\x06\\x07\u0026#39;, \u0026#39;\\x19\\x1f\\x1e\\x15\\x16\\x17\u0026#39;, \u0026#34;)/.%\u0026amp;\u0026#39;\u0026#34;, \u0026#39;9?\u0026gt;567\u0026#39;, \u0026#39;IONEFG\u0026#39;, \u0026#39;Y_^UVW\u0026#39;, \u0026#39;ionefg\u0026#39;, \u0026#39;y\\x7f~uvw\u0026#39;, \u0026#39;\\x89\\x8f\\x8e\\x85\\x86\\x87\u0026#39;, \u0026#39;\\x99\\x9f\\x 9e\\x95\\x96\\x97\u0026#39;] 随便选一个\u0026quot;IONEFG\u0026quot;输进去过关。\n","permalink":"http://localhost:1313/posts/csapp-lab2-phase-5/","summary":"\u003cp\u003e介绍：这是一个“拆弹”游戏，玩家要在反汇编中找到每一关的拆弹密码，一共有6个phases。\n该Lab的下载地址：\u003ca href=\"http://csapp.cs.cmu.edu/3e/labs.html\"\u003ehttp://csapp.cs.cmu.edu/3e/labs.html\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e警告：本文含有剧透内容，想要玩Lab2的慎看！\u003c/strong\u003e\u003c/p\u003e","title":"[CSAPP] Lab2 Phase 5 解谜笔记"},{"content":"介绍：这是一个“拆弹”游戏，玩家要在反汇编中找到每一关的拆弹密码，一共有6个phases。 该Lab的下载地址：http://csapp.cs.cmu.edu/3e/labs.html。\n警告：本文含有剧透内容，想要玩Lab2的慎看！\n首先先看一下phase_4的汇编\n000000000040100c \u0026lt;phase_4\u0026gt;: 40100c:\tsub $0x18,%rsp 401010: lea 0xc(%rsp),%rcx 401015: lea 0x8(%rsp),%rdx 40101a: mov $0x4025cf,%esi 40101f:\tmov $0x0,%eax 401024: callq 400bf0 \u0026lt;__isoc99_sscanf@plt\u0026gt;= 401029: cmp $0x2,%eax 40102c:\tjne 401035 \u0026lt;phase_4+0x29\u0026gt; 40102e:\tcmpl $0xe,0x8(%rsp) 401033: jbe 40103a \u0026lt;phase_4+0x2e\u0026gt; 401035: callq 40143a \u0026lt;explode_bomb\u0026gt; 40103a: mov $0xe,%edx 40103f:\tmov $0x0,%esi 401044: mov 0x8(%rsp),%edi 401048: callq 400fce \u0026lt;func4\u0026gt; 40104d: test %eax,%eax 40104f: jne 401058 \u0026lt;phase_4+0x4c\u0026gt; 401051: cmpl $0x0,0xc(%rsp) 401056:\tje 40105d \u0026lt;phase_4+0x51\u0026gt; 401058:\tcallq 40143a \u0026lt;explode_bomb\u0026gt; 40105d:\tadd $0x18,%rsp 401061:\tretq 通过汇编分析可知，第7行处调用了sscanf(rdi, *0x4025cf, rsp+0x8, rsp+0xc)，其中*0x4025cf即\u0026quot;%d %d\u0026quot;，将两个数读入到了栈上（后用N1,N2代指这两个数）。 接着在第11行处可以分析出N1\u0026lt;=0xe。 16行又是一个函数调用（参数个数未知，估计是3个），func4(rdi,0,0xE). 通过后面的代码可以推测出func4的返回值为0且N2为0。所以现在的目标就是找到N1使func4(N1,0,0xE)==0。\n然后来看看func4吧：\n0000000000400fce \u0026lt;func4\u0026gt;: ;edi=N1, esi=0, edx=0xE 400fce:\tsub $0x8,%rsp 400fd2: mov %edx,%eax ;eax=arg3 400fd4: sub %esi,%eax ;eax-=arg2 400fd6: mov %eax,%ecx ;ecx=eax=arg3-arg2 400fd8: shr $0x1f,%ecx ;ecx\u0026gt;\u0026gt;=0x1f (logic) 400fdb:\tadd %ecx,%eax ;eax+=ecx 400fdd:\tsar %eax ;eax/=2 400fdf:\tlea (%rax,%rsi,1),%ecx ;ecx=rax+rsi 400fe2:\tcmp %edi,%ecx 400fe4:\tjle 400ff2 \u0026lt;func4+0x24\u0026gt; ;ecx\u0026lt;=edi -\u0026gt; 400ff2 400fe6:\tlea -0x1(%rcx),%edx ;edx=rcx-1 400fe9:\tcallq 400fce \u0026lt;func4\u0026gt; 400fee:\tadd %eax,%eax 400ff0:\tjmp 401007 \u0026lt;func4+0x39\u0026gt; 400ff2:\tmov $0x0,%eax 400ff7: cmp %edi,%ecx 400ff9: jge 401007 \u0026lt;func4+0x39\u0026gt; 400ffb: lea 0x1(%rcx),%esi 400ffe: callq 400fce \u0026lt;func4\u0026gt; 401003: lea 0x1(%rax,%rax,1),%eax 401007: add $0x8,%rsp 40100b:\tretq 然后将其手动翻译成等价的伪C代码：\nfunc4(edi=N1, esi=0, edx=0xE){ eax=edx; eax-=esi; ecx=eax=edx-esi; ecx\u0026gt;\u0026gt;=0x1f (logic); eax+=ecx; eax/=2; ecx=rax+rsi; if(ecx\u0026lt;=edi) goto 400ff2; edx=rcx-1; func4(edi,esi,edx); eax*=2; goto 401007; 400ff2: eax=0; if(ecx\u0026gt;=edi) goto 401007; esi=rcx+1; func4(edi,esi,edx); eax=rax+rax+1; 401007: return eax; } func4(N1,0,0xE); 然后再稍微整(魔)理(改)下：\nfunc4(edi=N1, esi=0, edx=0xE){ ret=(edx-esi+sign(edx-esi))/2; //sign(ecx)是ecx的符号位 ecx=ret+esi; if(ecx\u0026gt;edi){ return func4(N1,esi,ecx-1)*2; } if(ecx\u0026lt;edi){ return func4(N1,ecx+1,edx)*2+1; } return 0; } func4(N1,0,0xE); 这里发现中间的代码是两个if，然后前面的移位其实是在取符号位。 可以看出这一段代码其实是类似于二分查找的东西，那么想让返回值为0的话，需要ecx\u0026gt;=edi。edi直接取0试了一下，竟然过了。 所以N1=0,N2=0。 phase4的答案为\u0026quot;0 0\u0026quot;。\n","permalink":"http://localhost:1313/posts/csapp-lab2-phase-4/","summary":"\u003cp\u003e介绍：这是一个“拆弹”游戏，玩家要在反汇编中找到每一关的拆弹密码，一共有6个phases。\n该Lab的下载地址：\u003ca href=\"http://csapp.cs.cmu.edu/3e/labs.html\"\u003ehttp://csapp.cs.cmu.edu/3e/labs.html\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e警告：本文含有剧透内容，想要玩Lab2的慎看！\u003c/strong\u003e\u003c/p\u003e","title":"[CSAPP] Lab2 Phase 4 解谜笔记"},{"content":"介绍：这是一个“拆弹”游戏，玩家要在反汇编中找到每一关的拆弹密码，一共有6个phases。 该Lab的下载地址：http://csapp.cs.cmu.edu/3e/labs.html。\n警告：本文含有剧透内容，想要玩Lab2的慎看！\n首先先看一下phase_3的汇编\n0000000000400f43 \u0026lt;phase_3\u0026gt;: 400f43:\tsub $0x18,%rsp 400f47: lea 0xc(%rsp),%rcx 400f4c: lea 0x8(%rsp),%rdx 400f51: mov $0x4025cf,%esi 400f56:\tmov $0x0,%eax 400f5b: callq 400bf0 \u0026lt;__isoc99_sscanf@plt\u0026gt; 400f60: cmp $0x1,%eax 400f63:\tjg 400f6a \u0026lt;phase_3+0x27\u0026gt; 400f65:\tcallq 40143a \u0026lt;explode_bomb\u0026gt; 400f6a:\tcmpl $0x7,0x8(%rsp) 400f6f: ja 400fad \u0026lt;phase_3+0x6a\u0026gt; 400f71: mov 0x8(%rsp),%eax 400f75: jmpq *0x402470(,%rax,8) 400f7c: mov $0xcf,%eax 400f81: jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f83: mov $0x2c3,%eax 400f88: jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f8a: mov $0x100,%eax 400f8f: jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f91: mov $0x185,%eax 400f96: jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f98: mov $0xce,%eax 400f9d: jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f9f: mov $0x2aa,%eax 400fa4: jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400fa6: mov $0x147,%eax 400fab: jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400fad: callq 40143a \u0026lt;explode_bomb\u0026gt; 400fb2: mov $0x0,%eax 400fb7: jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400fb9: mov $0x137,%eax 400fbe:\tcmp 0xc(%rsp),%eax 400fc2:\tje 400fc9 \u0026lt;phase_3+0x86\u0026gt; 400fc4:\tcallq 40143a \u0026lt;explode_bomb\u0026gt; 400fc9:\tadd $0x18,%rsp 400fcd:\tretq 这段汇编首先读入了两个数字N1,N2，存到了栈上，下面是等价的伪c代码： eax=sscanf(rdi,\u0026quot;%d %d\u0026quot;,rsp+0x8,rsp+0xc) 然后11行这里进行判断，限制N1\u0026lt;=7。 第14行，有趣的事情发生了：jmpq *0x402470(,%rax,8)当时猜了好久什么意思，查了一下发现是间接跳转。 用gdb查一下那个地址有什么值：\n(gdb) x/8ag 0x402470 0x402470: 0x400f7c \u0026lt;phase_3+57\u0026gt; 0x400fb9 \u0026lt;phase_3+118\u0026gt; 0x402480: 0x400f83 \u0026lt;phase_3+64\u0026gt; 0x400f8a \u0026lt;phase_3+71\u0026gt; 0x402490: 0x400f91 \u0026lt;phase_3+78\u0026gt; 0x400f98 \u0026lt;phase_3+85\u0026gt; 0x4024a0: 0x400f9f \u0026lt;phase_3+92\u0026gt; 0x400fa6 \u0026lt;phase_3+99\u0026gt; 果然，这是个跳转表。结合上面的代码可以猜测出来这是个switch。 随便找了一个组合过关。\n","permalink":"http://localhost:1313/posts/csapp-lab2-phase-3/","summary":"\u003cp\u003e介绍：这是一个“拆弹”游戏，玩家要在反汇编中找到每一关的拆弹密码，一共有6个phases。\n该Lab的下载地址：\u003ca href=\"http://csapp.cs.cmu.edu/3e/labs.html\"\u003ehttp://csapp.cs.cmu.edu/3e/labs.html\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e警告：本文含有剧透内容，想要玩Lab2的慎看！\u003c/strong\u003e\u003c/p\u003e","title":"[CSAPP] Lab2 Phase 3 解谜笔记"},{"content":"介绍：这是一个“拆弹”游戏，玩家要在反汇编中找到每一关的拆弹密码，一共有6个phases。 该Lab的下载地址：http://csapp.cs.cmu.edu/3e/labs.html。\n警告：本文含有剧透内容，想要玩Lab2的慎看！\n先看phase_1\n0000000000400ee0 \u0026lt;phase_1\u0026gt;: 400ee0:\tsub $0x8,%rsp 400ee4: mov $0x402400,%esi 400ee9:\tcallq 401338 \u0026lt;strings_not_equal\u0026gt; 400eee:\ttest %eax,%eax 400ef0:\tje 400ef7 \u0026lt;phase_1+0x17\u0026gt; 400ef2:\tcallq 40143a \u0026lt;explode_bomb\u0026gt; 400ef7:\tadd $0x8,%rsp 400efb:\tretq 很短很简单，第2行和第8行是分配和释放栈空间，用来存放局部变量。 第3行将地址放到esi，并在第4行调用了函数strings_not_equal。根据寄存器表 可以看出这里的调用是strings_not_equal(input, *0x402400) 然后第5,6行进行了比较，如果字符串相同才不炸。 剩下的就简单了，用gdb查一下那个地址存着什么就可以了：\n(gdb) x/s 0x402400 0x402400: \u0026#34;Border relations with Canada have never been better.\u0026#34; 输入该字符串过关。\n接下来是phase2\n0000000000400efc \u0026lt;phase_2\u0026gt;: 400efc:\tpush %rbp 400efd:\tpush %rbx 400efe:\tsub $0x28,%rsp 400f02: mov %rsp,%rsi ;rsi=rsp 400f05 callq 40145c \u0026lt;read_six_numbers\u0026gt; ;read 6 numbers into rsp,+4,+8,+12,+16,+20 400f0a: cmpl $0x1,(%rsp) 400f0e:\tje 400f30 \u0026lt;phase_2+0x34\u0026gt; ;N1==1 400f10:\tcallq 40143a \u0026lt;explode_bomb\u0026gt; 400f15:\tjmp 400f30 \u0026lt;phase_2+0x34\u0026gt; 400f17:\tmov -0x4(%rbx),%eax ;eax=*(rbx-4) 400f1a:\tadd %eax,%eax ;eax*=2 400f1c:\tcmp %eax,(%rbx) 400f1e:\tje 400f25 \u0026lt;phase_2+0x29\u0026gt; ;if *rbx==eax 400f20:\tcallq 40143a \u0026lt;explode_bomb\u0026gt; ; | 400f25: add $0x4,%rbx ; rbx+=4 400f29: cmp %rbp,%rbx 400f2c: jne 400f17 \u0026lt;phase_2+0x1b\u0026gt; ;if rbx!=rbp -\u0026gt;400f17 400f2e: jmp 400f3c \u0026lt;phase_2+0x40\u0026gt; ;else -\u0026gt;400f3c 400f30: lea 0x4(%rsp),%rbx ;rbx=rsp+4 400f35: lea 0x18(%rsp),%rbp ;rbp=rsp+24 400f3a: jmp 400f17 \u0026lt;phase_2+0x1b\u0026gt; ;-\u0026gt;400f17 400f3c: add $0x28,%rsp 400f40:\tpop %rbx 400f41:\tpop %rbp 400f42:\tretq 汇编的含义已经注释在代码里了，一开始用函数read_six_numbers读入了6个数到栈上（那个函数我读了半天(╯‵□′)╯︵┻━┻），然后观察可以看出来中间的部分其实是一个for循环，17-19行是判断语句，20-22行是初始化语句，11-16行则是循环体。转换成伪c代码大约是这样的：\nfor(rbx=rsp+4,rbp=rsp+24;rbx!=rbp;rbx+=4){ if((*(rbx-4))*2!=*rbx) explode_bomb(); } 结合第8行N1需要等于1的要求，很明显这段代码是要求6个由1开头每次*2的等比数列，即1 2 4 8 16 32。\n","permalink":"http://localhost:1313/posts/csapp-lab2-phase-12/","summary":"\u003cp\u003e介绍：这是一个“拆弹”游戏，玩家要在反汇编中找到每一关的拆弹密码，一共有6个phases。\n该Lab的下载地址：\u003ca href=\"http://csapp.cs.cmu.edu/3e/labs.html\"\u003ehttp://csapp.cs.cmu.edu/3e/labs.html\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e警告：本文含有剧透内容，想要玩Lab2的慎看！\u003c/strong\u003e\u003c/p\u003e","title":"[CSAPP] Lab2 Phase 1,2 解谜笔记"}]