// This program was generated by ChatGPT.

import util.*;

/* Note that this implementation assumes that the graph is represented as an
 * array of List objects.
 */
public class Main {
    public Main() {}

    public static List kosaraju(int numVertices, List[] graph) {
        List result = new ArrayList();
        boolean[] visited = new boolean[numVertices];
        Stack stack = new ArrayStack();

        // First pass: fill the stack with the vertices in post-order
        for (int i = 0; i < numVertices; i = i + 1) {
            if (!visited[i]) {
                Main.dfs(i, graph, visited, stack);
            }
        }

        // Transpose the graph
        List[] transpose = new List[numVertices];
        for (int i = 0; i < numVertices; i = i + 1) {
            transpose[i] = new ArrayList();
        }
        for (int i = 0; i < numVertices; i = i + 1) {
            List neighbors = graph[i];
            for (int j = 0; j < neighbors.size(); j = j + 1) {
                Integer v = (Integer) neighbors.get(j);
                transpose[v.intValue()].add((Object) new Integer(i));
            }
        }

        // Second pass: visit the vertices in the order defined by the stack
        Arrays.fill(visited, false);
        while (!stack.empty()) {
            int v = ((Integer) stack.pop()).intValue();
            if (!visited[v]) {
                List component = new ArrayList();
                Main.dfs(v, transpose, visited, component);
                result.add((Object) component);
            }
        }

        return result;
    }

    protected static void dfs(int v, List[] graph, boolean[] visited, Stack stack) {
        visited[v] = true;
        List neighbors = graph[v];
        for (int i = 0; i < neighbors.size(); i = i + 1) {
            int u = ((Integer) neighbors.get(i)).intValue();
            if (!visited[u]) {
                Main.dfs(u, graph, visited, stack);
            }
        }
        stack.push((Object) new Integer(v));
    }

    protected static void dfs(int v, List[] graph, boolean[] visited, List component) {
        visited[v] = true;
        component.add((Object) new Integer(v));
        List neighbors = graph[v];
        for (int i = 0; i < neighbors.size(); i = i + 1) {
            int u = ((Integer) neighbors.get(i)).intValue();
            if (!visited[u]) {
                Main.dfs(u, graph, visited, component);
            }
        }
    }

    public static void main(String[] args) {
        java.lang.System.out.println(Main.test());
    }

    public static int test() {
        // Create a test graph with 5 vertices
        List[] graph = new List[5];
        for (int i = 0; i < 5; i = i + 1) {
            graph[i] = new ArrayList();
        }
        graph[0].add((Object) new Integer(4));
        graph[1].add((Object) new Integer(3));
        graph[2].add((Object) new Integer(1));
        graph[3].add((Object) new Integer(2));
        graph[3].add((Object) new Integer(0));
        graph[4].add((Object) new Integer(0));

        // Compute the strongly connected components of the graph
        List components = Main.kosaraju(5, graph);

        // Verify the result
        List sccs = new ArrayList();
        for (int i = 0; i < components.size(); i = i + 1) {
            String scc = "";
            List component = (List) components.get(i);
            for (int j = 0; j < component.size(); j = j + 1) {
                Integer v = (Integer) component.get(j);
                scc = scc + v;
            }
            sccs.add((Object) scc);
        }
        if (sccs.size() != 2) {
            return ((Object) null).hashCode();
        }
        return Integer.parseInt((String) sccs.get(0));
    }
}